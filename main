/*!
 * Copyright (c) 2018 Aaron Delasy
 * Licensed under the MIT License
 */

AUTH_TOKEN := "pELerETRaVeYHEne"
ENDPOINT_URL := "https://api.thelang.io"

VERSION_NUM := "0.11.0"
VERSION_NAME := "Open Source"

obj ParsedFile {
  comments: str
  definitions: str
  content: str
  mainContent: str
}

fn RaiseError (message: str) {
  print("Error: " + message, to: "stderr")
  exit(1)
}

fn chmodAddSync (path: str, mode: int) {
  stat := fs_statSync(path)
  fs_chmodSync(path, stat.mode | mode)
}

fn parseFile (fileContent: str) ParsedFile {
  mut comments := ""
  mut definitions := ""
  mut content := ""
  mut mainContent := ""

  mut prevCh: char
  mut isComment := false
  mut isDefinition := false
  mut isMainContent := false
  mut blocks := 0

  loop i := 0; i < fileContent.len; i++ {
    ch := fileContent[i]

    if prevCh != '\\' && fileContent.slice(i, i + 3) == "/" + "*!" {
      comments += "/" + "*!"
      isComment = true
      i += 2
    } elif isComment && fileContent.slice(i, i + 2) == "*/" {
      comments += "*/" + os_EOL
      isComment = false
      i += 1
    } elif prevCh.isSpace() && fileContent.slice(i, i + 4) == "obj " {
      definitions += "obj "
      isDefinition = true
      i += 3
    } elif prevCh.isSpace() && fileContent.slice(i, i + 5) == "enum " {
      definitions += "enum "
      isDefinition = true
      i += 4
    } elif isDefinition && ch == '}' {
      definitions += "}" + os_EOL
      isDefinition = false
    } elif prevCh.isSpace() && fileContent.slice(i, i + 5) == "main " {
      mainContent += "main "
      isMainContent = true
      i += 4
    } elif isMainContent && ch == '{' {
      mainContent += "{"
      blocks++
    } elif isMainContent && ch == '}' && blocks == 0 {
      mainContent += "}" + os_EOL
      isMainContent = false
    } elif isMainContent && ch == '}' {
      mainContent += "}"
      blocks--
    } elif isComment {
      comments += ch.str()
    } elif isDefinition {
      definitions += ch.str()
    } elif isMainContent {
      mainContent += ch.str()
    } else {
      content += ch.str()
    }

    prevCh = ch
  }

  return ParsedFile{
    comments: comments,
    definitions: definitions,
    content: content.trim() + os_EOL,
    mainContent: mainContent
  }
}

fn build () {
  print("Starting build")

  allFiles := fs_scandirSync(".")
  mut files: str[]

  loop i := 0; i < allFiles.len; i++ {
    file := allFiles[i]

    if fs_isFileSync(file) && file.find(".") == -1 {
      files.push(file)
    }
  }

  mut comments := ""
  mut definitions := ""
  mut content := ""
  mut mainContent := ""

  loop i := 0; i < files.len; i++ {
    file := files[i]
    print("Processing file: " + file)

    fileContent := fs_readFileSync(file).str()
    parsedContent := parseFile(fileContent)

    comments += parsedContent.comments
    definitions += parsedContent.definitions
    content += parsedContent.content

    if !parsedContent.mainContent.empty() && !mainContent.empty() {
      RaiseError("Found multiple blocks of main")
    } elif !parsedContent.mainContent.empty() {
      mainContent = parsedContent.mainContent
    }
  }

  buildDir := process_cwd() + "/build"
  print("Checking build directory: " + buildDir)

  if !fs_existsSync(buildDir) {
    print("Creating build directory: " + buildDir)
    fs_mkdirSync(buildDir)
  }

  result := comments + definitions + content + mainContent
  fs_writeFileSync(buildDir + "/result", result.toBuffer())

  print("Build finished: " + buildDir + "/result")
}

fn defaultPlatform () str {
  if os_name() == "macOS" {
    return "macos"
  } elif os_name() == "Windows" {
    return "windows"
  } else {
    return "linux"
  }
}

fn download (url: str, path: str) {
  reqHeaders := [
    request_Header{name: "authorization", value: AUTH_TOKEN},
    request_Header{name: "content-type", value: "application/octet-stream"}
  ]

  mut req := request_open(
    "POST",
    url,
    headers: reqHeaders,
    data: fs_readFileSync(path)
  )

  res := request_read(ref req)
  request_close(ref req)

  fs_writeFileSync(process_cwd() + "/a.out", res.data)
  chmodAddSync(process_cwd() + "/a.out", 0o100)
}

fn request (url: str, path: str) {
  reqHeaders := [
    request_Header{name: "authorization", value: AUTH_TOKEN},
    request_Header{name: "content-type", value: "application/octet-stream"}
  ]

  mut req := request_open(
    "POST",
    url,
    headers: reqHeaders,
    data: fs_readFileSync(path)
  )

  res := request_read(ref req)
  request_close(ref req)
  data := res.data.str()

  if data.empty() {
    RaiseError("Server didn't return any data")
  }

  print(data, terminator: "")
}

main {
  args := process_args.slice(1)

  if args.empty() {
    RaiseError("Action is not set")
  } elif args.len == 1 && (args[0] == "-h" || args[0] == "--help") {
    print(
      os_EOL +
      "  Usage:" + os_EOL +
      os_EOL +
      "     the [option]" + os_EOL +
      "     the [action] file [options]" + os_EOL +
      os_EOL +
      "  Options:" + os_EOL +
      os_EOL +
      "    -h, --help        Print help information" + os_EOL +
      "    -v, --version     Print version" + os_EOL +
      os_EOL +
      "  Actions:" + os_EOL +
      os_EOL +
      "    build             " +
      "Build source directory into single file" + os_EOL +
      "    compile           Compile file" + os_EOL +
      "    lex               Lex file" + os_EOL +
      "    parse             Parse file" + os_EOL +
      "    run               Run file" + os_EOL +
      "    upgrade           Self-upgrade CLI to newest version" + os_EOL +
      os_EOL +
      "  Options:" + os_EOL +
      os_EOL +
      "    --platform=...    " +
      "Specify target platform, one of: linux, macos," + os_EOL +
      "                      " +
      "windows. Applies to actions: compile, run." + os_EOL +
      "    --the=...         " +
      "Specify The Programming Language version, valid" + os_EOL +
      "                      formats: latest, 1, 1.1, 1.1.1" + os_EOL +
      os_EOL +
      "  Examples:" + os_EOL +
      os_EOL +
      "    $ the -h" + os_EOL +
      "    $ the --version" + os_EOL +
      os_EOL +
      "    $ the build" + os_EOL +
      "    $ the compile /path/to/file" + os_EOL +
      "    $ the lex /path/to/file" + os_EOL +
      "    $ the compile /path/to/file --the=1.0" + os_EOL +
      "    $ the lex /path/to/file --the=1.0.0" + os_EOL +
      "    $ the run /path/to/file --platform=macos" + os_EOL +
      "    $ the upgrade" + os_EOL
    )

    exit()
  } elif args.len == 1 && (args[0] == "-v" || args[0] == "--version") {
    print(
      "The Programming Language" + os_EOL +
      "Version " + VERSION_NUM + " (" + VERSION_NAME + ")" + os_EOL +
      "Copyright (c) 2018 Aaron Delasy"
    )

    exit()
  }

  mut filePath := ""
  mut platform := defaultPlatform()
  mut version := "latest"

  mut isBuild := false
  mut isCompile := false
  mut isLex := false
  mut isParse := false
  mut isRun := false
  mut isUpgrade := false

  loop i := 0; i < args.len; i++ {
    arg := args[i]

    if i == 0 {
      if arg == "build" {
        isBuild = true
      } elif arg == "compile" {
        isCompile = true
      } elif arg == "lex" {
        isLex = true
      } elif arg == "parse" {
        isParse = true
      } elif arg == "run" {
        isRun = true
      } elif arg == "upgrade" {
        isUpgrade = true
      } else {
        RaiseError("Unknown action '" + arg + "'")
      }
    } elif i == 1 {
      fileRelativeDir := path_dirname(arg)
      fileDir := fileRelativeDir.slice(0, 1) == "/"
        ? fileRelativeDir
        : fs_realpathSync(process_cwd() + "/" + fileRelativeDir)
      filePath = fileDir + "/" + path_basename(arg)

      if !fs_existsSync(filePath) {
        RaiseError("File '" + filePath + "' does not exists")
      } elif !fs_isFileSync(filePath) {
        RaiseError("Path '" + filePath + "' is not a file")
      }
    } elif arg.slice(0, 6) == "--the=" {
      version = arg.slice(6)
    } elif arg.slice(0, 11) == "--platform=" {
      platform = arg.slice(11)
    } else {
      RaiseError("Unknown option '" + arg + "'")
    }
  }

  if !isBuild && filePath.empty() {
    RaiseError("File path is not set")
  }

  qs := "?v=" + version + "&p=" + platform

  if isBuild {
    build()
  } elif isCompile {
    download(ENDPOINT_URL + "/compile" + qs, filePath)
  } elif isLex {
    request(ENDPOINT_URL + "/lex" + qs, filePath)
  } elif isParse {
    request(ENDPOINT_URL + "/parse" + qs, filePath)
  } elif isRun {
    download(ENDPOINT_URL + "/compile" + qs, filePath)
    stdout := process_runSync(process_cwd() + "/a.out")
    fs_unlinkSync(process_cwd() + "/a.out")

    print(stdout.str(), terminator: "")
  } elif isUpgrade {
    mut req := request_open("GET", "https://cdn.thelang.io/cli-core-" + platform)
    res := request_read(ref req)
    request_close(ref req)

    fs_writeFileSync("/usr/local/bin/the", res.data)
    chmodAddSync("/usr/local/bin/the", 0o100)
  }
}
