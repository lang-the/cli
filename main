/*!
 * Copyright (c) 2018 Aaron Delasy
 * Licensed under the MIT License
 */

AUTH_TOKEN := "pELerETRaVeYHEne"
ENDPOINT_URL := "https://api.thelang.io"

VERSION_NUM := "0.11.0"
VERSION_NAME := "Open Source"

obj ParsedFile {
  comments: str
  definitions: str
  content: str
}

fn panic (message: str) {
  print("Error: " + message, to: "stderr")
  exit(1)
}

fn chmodAdd (path: str, mode: int) {
  stat := fs_statSync(path)
  fs_chmodSync(path, stat.mode | mode)
}

fn parseFile (fileContent: str) ParsedFile {
  mut comments := ""
  mut definitions := ""
  mut content := ""

  mut prevCh: char
  mut isComment := false
  mut isDefinition := false

  loop i := 0; i < content.len; i++ {
    ch := content[i]

    if (
      prevCh != '\\' && ch == '/' &&
      i + 1 < conten.len && content[i + 1] == '*' &&
      i + 2 < conten.len && content[i + 2] == '!'
    ) {
      comments += "/*!"
      isComment = true
      i += 2
    } elif (
      isComment && ch == '*' &&
      i + 1 < conten.len && content[i + 1] == '/'
    ) {
      comments += "*/\n"
      isComment = false
      i += 1
    } elif (
      (prevCh == '\n' || prevCh == '\r' || prevCh == '\t' || prevCh == ' ') &&
      ch == 'o' &&
      i + 1 < conten.len && content[i + 1] == 'b' &&
      i + 2 < conten.len && content[i + 2] == 'j' &&
      i + 3 < conten.len && content[i + 3] == ' '
    ) {
      definitions += "obj "
      isDefinition = true
      i += 3
    } elif (
      (prevCh == '\n' || prevCh == '\r' || prevCh == '\t' || prevCh == ' ') &&
      ch == 'e' &&
      i + 1 < conten.len && content[i + 1] == 'n' &&
      i + 2 < conten.len && content[i + 2] == 'u' &&
      i + 3 < conten.len && content[i + 3] == 'm' &&
      i + 4 < conten.len && content[i + 4] == ' '
    ) {
      definitions += "enum "
      isDefinition = true
      i += 4
    } elif isDefinition && ch == '}' {
      comments += "}\n"
      isDefinition = false
    } elif isComment {
      comments += ch.str()
    } elif isDefinition {
      comments += ch.str()
    } else {
      content += ch.str()
    }

    prevCh = ch
  }

  return ParsedFile{
    comments: comments,
    definitions: definitions,
    content: content.trim()
  }
}

fn build () {
  print("Starting build")

  dirName := PWD + "/"
  buildDir := PWD + "/build"
  dirFiles := fs_readDirSync(dirName)

  mut files: str[]

  loop i := 0; i < dirFiles.len; i++ {
    file := dirFiles[i]
    fileName := file.slice(dirName.len)

    if fs_isFileSync(file) && fileName.find(".") == -1 {
      files.push(fileName)
    }
  }

  mut comments := ""
  mut definitions := ""
  mut content := ""

  loop i := 0; i < files.len; i++ {
    file := files[i]
    print("Processing file: " + file)

    fileContent := fs_readFileSync(file, "utf8")
    parsedContent = parseFile(fileContent)

    comments += parsedContent.comments
    definitions += parsedContent.definitions
    content += parsedContent.content
  }

  print("Checking build directory: " + buildDir)

  if !fs_existsSync(buildDir) {
    print("Creating build directory: " + buildDir)
    fs_mkdirSync(buildDir)
  }

  result := comments + definitions + content
  fs_writeFileSync(buildDir + "/result", result.toBuffer())

  print("Build finished: " + buildDir + "/result")
}

fn defaultPlatform () str {
  if OS == "macOS" {
    return "macos"
  } elif OS == "Windows" {
    return "windows"
  } else {
    return "linux"
  }
}

fn download (url: str, path: str) {
  req := request_post(url, RequestOptions{
    headers: RequestHeaders{
      authorization: AUTH_TOKEN,
      content_type: "application/octet-stream"
    },
    data: fs_readFileSync(path, "utf8")
  })

  res := request_read(req)
  request_close(req)

  fs_writeFileSync(PWD + "/a.out", res)
  chmodAdd(PWD + "/a.out", 0o100)
}

fn request (url: str, path: str) {
  req := request_post(url, RequestOptions{
    headers: RequestHeaders{
      authorization: AUTH_TOKEN,
      content_type: "application/octet-stream"
    },
    data: fs_readFileSync(path, "utf8")
  })

  res := request_read(req)
  request_close(req)
  data := res.str()

  if data.len > 0 {
    print(data)
  } else {
    print("Server didn't return any data")
  }
}

main {
  args := ARGS.slice(1)

  if args.len == 0 {
    panic("Action is not set")
  } elif args.len == 1 && (args[0] == "-h" || args[0] == "--help") {
    print(
      EOL +
      "  Usage:" + EOL +
      EOL +
      "     the [option]" + EOL +
      "     the [action] file [options]" + EOL +
      EOL +
      "  Options:" + EOL +
      EOL +
      "    -h, --help        Print help information" + EOL +
      "    -v, --version     Print version" + EOL +
      EOL +
      "  Actions:" + EOL +
      EOL +
      "    build             Build source directory into single file" + EOL +
      "    compile           Compile file" + EOL +
      "    lex               Lex file" + EOL +
      "    parse             Parse file" + EOL +
      "    run               Run file" + EOL +
      "    upgrade           Self-upgrade CLI to newest version" + EOL +
      EOL +
      "  Options:" + EOL +
      EOL +
      "    --platform=...    Specify target platform, one of: linux, macos," + EOL +
      "                      windows. Applies to actions: compile, run." + EOL +
      "    --the=...         Specify The Programming Language version, valid" + EOL +
      "                      formats: latest, 1, 1.1, 1.1.1" + EOL +
      EOL +
      "  Examples:" + EOL +
      EOL +
      "    $ the -h" + EOL +
      "    $ the --version" + EOL +
      EOL +
      "    $ the build" + EOL +
      "    $ the compile /path/to/file" + EOL +
      "    $ the lex /path/to/file" + EOL +
      "    $ the compile /path/to/file --the=1.0" + EOL +
      "    $ the lex /path/to/file --the=1.0.0" + EOL +
      "    $ the run /path/to/file --platform=macos" + EOL +
      "    $ the upgrade" + EOL
    )

    exit(0)
  } elif args.len == 1 && (args[0] == "-v" || args[0] == "--version") {
    print(
      "The Programming Language" + EOL +
      "Version " + VERSION_NUM + " (" + VERSION_NAME + ")" + EOL +
      "Copyright (c) 2018 Aaron Delasy"
    )

    exit(0)
  }

  mut filePath := ""
  mut platform := defaultPlatform()
  mut version := "latest"

  mut isBuild := false
  mut isCompile := false
  mut isLex := false
  mut isParse := false
  mut isRun := false
  mut isUpgrade := false

  loop i = 0; i < args.len; i++ {
    arg := args[i]

    if i == 1 {
      if arg == "build" {
        isBuild = true
      } elif arg == "compile" {
        isCompile = true
      } elif arg == "lex" {
        isLex = true
      } elif arg == "parse" {
        isParse = true
      } elif arg == "run" {
        isRun = true
      } elif arg == "upgrade" {
        isUpgrade = true
      } else {
        panic("Unknown action '" + arg + "'")
      }
    } elif i == 2 {
      fileRelativeDir := path_dirname(arg)
      fileDir := fileRelativeDir.slice(0, 1) == "/"
        ? fileRelativeDir
        : fs_realpathSync(PWD + "/" + fileRelativeDir)
      filePath = fileDir + "/" + path_basename(arg)

      if !fs_existsSync(filePath) {
        panic("File '" + filePath + "' does not exists")
      } elif !fs_isDirectorySync(filePath) {
        panic("Path '" + filePath + "' is not a file")
      }
    } elif arg.slice(0, 6) == "--the=" {
      version = arg.slice(6)
    } elif arg.slice(0, 11) == "--platform=" {
      platform = arg.slice(11)
    } else {
      panic("Unknown option '" + arg + "'")
    }
  }

  if !isBuild && filePath.len == 0 {
    panic("File path is not set")
  }

  if isBuild {
    build()
  } elif isCompile {
    download(ENDPOINT_URL + "/compile?v=" + version + "&p=" + platform, filePath)
  } elif isLex {
    request(ENDPOINT_URL + "/lex?v=" + version + "&p=" + platform, filePath)
  } elif isParse {
    request(ENDPOINT_URL + "/parse?v=" + version + "&p=" + platform, filePath)
  } elif isRun {
    download(ENDPOINT_URL + "/compile?v=" + version + "&p=" + platform, filePath)
    process_run(PWD + "/a.out")
    fs_unlinkSync(PWD + "/a.out")
  } elif isUpgrade {
    req := request_get("https://cdn.thelang.io/cli-core-" + platform)
    res := request_read(req)
    request_close(req)

    fs_writeFileSync("/usr/local/bin/the", res)
    chmodAdd("/usr/local/bin/the", 0o100)
  }
}
