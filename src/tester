/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import parse from "the/parser"
import collectImportPaths, collectTestFunctionNames from "./parser"
import excludePaths, removeDirectorySync, scandirDeepSync from "./utils"

export obj Tester {
  cwd: str
  targetPath: str
  exclude: str[]
  mut inputPath: str
  mut outputDir: str
  mut outputPath: str

  fn init (mut self: ref Self) {
    cwdLen := self.cwd.len
    fullPath := (fs_isAbsoluteSync(self.targetPath) ? "" : self.cwd + path_SEP) + self.targetPath
    realFullPath := fs_realpathSync(fullPath)

    if !fs_existsSync(realFullPath) {
      throw error_NewError("Path '" + realFullPath + "' doesn't exists")
    }

    self.outputDir = path_tempDirectory()
    self.inputPath = self.outputDir + path_SEP + "__the__main__"
    allFiles := fs_isDirectorySync(realFullPath) ? scandirDeepSync(realFullPath) : [realFullPath]
    files := excludePaths(allFiles, self.exclude)
    mut tests: str[][str]

    loop i := 0; i < files.len; i++ {
      f := parse(files[i])
      relativePath := "." + f.path.slice(cwdLen)
      fnNames := collectTestFunctionNames(ref f)
      mut fileContent := fs_readFileSync(f.path).str()

      if !fnNames.empty {
        tests.set(relativePath, fnNames)
        fileContent = "import EXPECT_EQ from \"the/testing\"" + os_EOL + fileContent
      }

      fs_writeFileSync(self.outputDir + relativePath, fileContent.toBuffer())
      importPaths := excludePaths(collectImportPaths(ref f), self.exclude)

      loop j := 0; j < importPaths.len; j++ {
        // todo the same as above
      }
    }

    testsKeys := tests.keys
    mut mainFileImports := "import Tests from \"the/testing\"" + os_EOL
    mut mainFile := "main {" + os_EOL + os_EOL
    mainFile += "  mut tests := Tests{}" + os_EOL

    loop i := 0; i < testsKeys.len; i++ {
      testsKey := testsKeys[i]
      mainFileImports += "import "
      testNames := tests.get(testsKey)

      loop j := 0; j < testNames.len; j++ {
        testName := testNames[j]
        testFnName := "TEST_" + testName
        mainFileImports += (j == 0 ? "" : ", ") + testFnName
        mainFile += "  tests.register(\"" + testName + "\", " + testFnName + ")" + os_EOL
      }

      mainFileImports += "from \"" + testsKey + "\"" + os_EOL
    }

    mainFile += "  tests.run(process_args)" + os_EOL
    mainFile += "}" + os_EOL

    mainContent := mainFileImports + os_EOL + mainFile
    self.outputPath = self.outputDir + path_SEP + "a." + (os_NAME == "Windows" ? "exe" : "out")
    fs_writeFileSync(self.inputPath, mainContent.toBuffer())
  }

  fn deinit (self: ref Self) {
    removeDirectorySync(self.outputDir)
  }
}

export fn Tester_init (targetPath: str, exclude: str[], cwd := process_cwd()) Tester {
  mut result := Tester{
    cwd: cwd,
    targetPath: targetPath,
    exclude: exclude
  }

  result.init()
  return result
}
