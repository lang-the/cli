/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

obj Tester {
  cwd: str
  targetPath: str
  excludePaths: str[]
  mut inputPath: str
  mut outputDir: str
  mut outputPath: str
  mut _includes: str[]
  mut _tests: str[]

  fn init (mut self: ref Self) {
    fullPath := (fs_isAbsoluteSync(self.targetPath) ? "" : self.cwd + path_SEP) + self.targetPath
    realFullPath := fs_realpathSync(fullPath)

    if !fs_existsSync(realFullPath) {
      RaiseError("Path '" + realFullPath + "' doesn't exists")
    }

    mut files: str[]

    if fs_isDirectorySync(realFullPath) {
      files = Builder_collectFiles(realFullPath, self.excludePaths)
      packageCollection := Builder_collectPackagesFiles(self.cwd)
      files.merge(packageCollection[0])
    } else {
      files.push(realFullPath)
    }

    mut parser := Parser{}
    mut comments := ""
    mut content := ""
    mut definitions := ""
    mut functions := ""
    mut testNames: str[]

    loop i := 0; i < files.len; i++ {
      parserResult := parser.parse(files[i])
      comments += parserResult.comments
      content += parserResult.content
      definitions += parserResult.definitions
      functions += parserResult.functions

      loop j := 0; j < parserResult.functionNames.len; j++ {
        functionName := parserResult.functionNames[j]

        if functionName.slice(0, 5) == "TEST_" {
          testNames.push(functionName.slice(5))
        }
      }
    }

    mut result := comments + content + definitions + functions
    result += "main {" + os_EOL
    result += "  mut tests := Tests{}" + os_EOL

    loop i := 0; i < testNames.len; i++ {
      testName := testNames[i]
      result += "  tests.register(\"" + testName + "\", TEST_" + testName + ")" + os_EOL
    }

    result += "  tests.run(process_args)" + os_EOL
    result += "}" + os_EOL

    self.outputDir = path_tempDirectory()
    self.inputPath = self.outputDir + path_SEP + "result"
    self.outputPath = self.outputDir + path_SEP + "a" + (os_NAME == "Windows" ? "exe" : "out")
    fs_writeFileSync(self.inputPath, result.toBuffer())
  }

  fn deinit (self: ref Self) {
    removeDirectorySync(self.outputDir)
  }
}

fn Tester_init (targetPath: str, excludePaths: str[], cwd := process_cwd()) Tester {
  mut result := Tester{
    cwd: cwd,
    targetPath: targetPath,
    excludePaths: excludePaths
  }

  result.init()
  return result
}
