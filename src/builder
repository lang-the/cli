/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

fn Builder_collectFiles (path: str, excludePaths: str[], tree := "") str[] {
  treePath := tree.empty ? path_basename(path) : tree
  entities := fs_scandirSync(path)
  mut result: str[]

  loop i := 0; i < entities.len; i++ {
    entity := entities[i]
    entityPath := path + path_SEP + entity
    entityTreePath := treePath + path_SEP + entity

    if (
      entity.find(".") == -1 &&
      fs_isFileSync(entityPath) &&
      !excludePaths.contains(entityTreePath) &&
      !excludePaths.contains(entity)
    ) {
      result.push(entityPath)
    } elif (
      entity.find(".") == -1 &&
      fs_isDirectorySync(entityPath) &&
      !excludePaths.contains(entityTreePath) &&
      !excludePaths.contains(entity)
    ) {
      files := Builder_collectFiles(entityPath, excludePaths, entityTreePath)
      result.merge(files)
    }
  }

  return result
}

fn Builder_collectPackagesFiles (
  cwd: str,
  mut includedPackages: str[] = [],
  root := true
) str[][] {
  packageYAMLPath := cwd + path_SEP + "package.yml"

  if !fs_existsSync(packageYAMLPath) {
    return [[], []]
  }

  packagesPath := cwd + path_SEP + ".packages"
  content := fs_readFileSync(packageYAMLPath).str()
  packageYaml := PackageYAML_parse(content)
  mut files: str[]

  if !root {
    files = packageYaml.files

    loop i := 0; i < files.len; i++ {
      files[i] = cwd + path_SEP + files[i]
    }
  }

  if fs_existsSync(packagesPath) {
    keys := packageYaml.packages.keys
    mut subPackagePaths: str[]

    loop i := 0; i < keys.len; i++ {
      key := keys[i]
      packagePath := packagesPath + path_SEP + key.replace("/", path_SEP)

      if includedPackages.contains(key) || !fs_existsSync(packagePath) {
        continue
      }

      subPackagePaths.push(packagePath)
      includedPackages.push(key)
    }

    loop i := 0; i < subPackagePaths.len; i++ {
      packageCollection := Builder_collectPackagesFiles(subPackagePaths[i], includedPackages, root: false)
      files.merge(packageCollection[0])
      includedPackages = packageCollection[1]
    }
  }

  return [files, includedPackages]
}

fn Builder_init (targetPath: str, buildDir: str, excludePaths: str[]) {
  fullPath := (fs_isAbsoluteSync(targetPath) ? "" : process_cwd() + path_SEP) + targetPath
  buildPath := fs_realpathSync(fullPath)

  if !fs_existsSync(buildPath) {
    RaiseError("File '" + buildPath + "' does not exists")
  } elif !fs_isDirectorySync(buildPath) {
    RaiseError("Path '" + buildPath + "' is not a directory")
  }

  print("Starting build")

  mut files := Builder_collectFiles(buildPath, excludePaths)
  packageCollection := Builder_collectPackagesFiles(process_cwd())
  files.merge(packageCollection[0])

  mut parser := Parser{}
  mut comments := ""
  mut content := ""
  mut definitions := ""
  mut functions := ""
  mut mainContent := ""

  loop i := 0; i < files.len; i++ {
    file: str = files[i]
    print("Processing file:", file)

    parserResult := parser.parse(file)
    comments += parserResult.comments
    content += parserResult.content
    definitions += parserResult.definitions
    functions += parserResult.functions

    if !parserResult.mainContent.empty && !mainContent.empty {
      RaiseError("Found multiple blocks of main")
    } elif !parserResult.mainContent.empty {
      mainContent = parserResult.mainContent
    }
  }

  if !fs_existsSync(buildDir) {
    fs_mkdirSync(buildDir)
  }

  result := comments + content + definitions + functions + mainContent
  fs_writeFileSync(buildDir + path_SEP + "result", result.toBuffer())

  print("Build finished:", buildDir + path_SEP + "result")
}
