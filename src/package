/*!
 * Copyright (c) 2018 Aaron Delasy
 * Licensed under the MIT License
 */

obj Package {
  name: str
  version: str
  cwd: str
  mut _globalPath: str
  mut _initialized: bool
  mut _metaFile: str
  mut _packagesProjectPath: str
  mut _projectPath: str
  mut _tempPath: str

  fn deinit () {
    self._checkInitialized("deinit")
    self._initialized = false
  }

  fn init (mut self: ref Self) ref Self {
    if self._initialized {
      RaiseError("tried package init on initialized")
    } elif !self.validName() {
      RaiseError("invalid package name")
    } elif !self.validVersion() {
      RaiseError("invalid package version")
    }

    self._packagesProjectPath = self.cwd + "/.packages"
    self._globalPath = Config_getPackagesPath() + "/" + self.name +
      "/" + self.version
    self._metaFile = PACKAGES_TEMP_PATH + "/" + self.name + ".yml"
    self._projectPath = self._packagesProjectPath + "/" + self.name
    self._tempPath = path_tempDirectory() + "/package"

    if !fs_isFileSync(self._metaFile) {
      RaiseError("metadata of package `" + self.name + "` does not exists")
    }

    self._initialized = true
    return self
  }

  fn download (self: ref Self) ref Self {
    self._checkInitialized("download")

    metaContent := fs_readFileSync(self._metaFile)
    meta := PackageMetadata_parse(metaContent.str())

    if !meta.existsVersion(self.version) {
      RaiseError(
        "package `" + self.name + "` " +
        "version `" + self.version + "` does not exists"
      )
    }

    process_runSync("git clone " + meta.repository + " " + self._tempPath)
    process_runSync("git reset --hard " + meta.getVersionHash(self.version))
    fs_rmdirSync(self._tempPath + "/.git")
    Config_initHome(packageAuthor: self.getAuthor())
    fs_mvSync(self._tempPath + meta.repositoryPath, self._globalPath)

    if !meta.repositoryPath.empty() {
      fs_rmdirSync(self._tempPath)
    }

    // todo parse package.yml and install dependency packages
    return self
  }

  fn install (self: ref Self) ref Self {
    self._checkInitialized("install")

    if fs_existsSync(self._projectPath) {
      return
    } elif !fs_existsSync(self._globalPath) {
      self.download()
    }

    if !fs_existsSync(self._packagesProjectPath) {
      fs_mkdirSync(self._packagesProjectPath)
    }

    author := self.getAuthor()

    if !fs_existsSync(self._packagesProjectPath + "/" + author) {
      fs_mkdirSync(self._packagesProjectPath + "/" + author)
    }

    fs_linkSync(self._globalPath, self._projectPath)
    return self
  }

  fn getAuthor (self: ref Self) str {
    return self.name.split("/")[0]
  }

  fn getProject (self: ref Self) str {
    return self.name.split("/")[1]
  }

  fn update (self: ref Self) ref Self {
    self._checkInitialized("update")
    // todo
    return self
  }

  fn validAuthor (self: ref Self) bool {
    val := self.getAuthor()
    // todo
  }

  fn validName (self: ref Self) bool {
    parts := self.name.split("/")
    hasProject := parts.len == 2 && !parts[1].empty()

    return hasProject ? self.validAuthor() && self.validProject() : false
  }

  fn validProject (self: ref Self) bool {
    val := self.getProject()
    // todo
  }

  fn validVersion (self: ref Self) bool {
    // todo
  }

  fn _checkInitialized (self: ref Self, callee: str) ref Self {
    if !self._initialized {
      RaiseError("tried package " + callee + " on non-initialized")
    }

    return self
  }
}

fn Package_fromArgument (val: str, cwd := process_cwd()) Package {
  parts := val.split("@")
  hasVersion := parts.len == 2 && !parts[1].empty()

  mut result := Package{
    name: hasVersion ? parts[0] : val,
    version: hasVersion ? parts[1] : "latest",
    cwd: cwd
  }

  result.init()
  return result
}
