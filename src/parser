/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

obj ParserResult {
  mut comments: str
  mut content: str
  mut definitions: str
  mut functions: str
  mut functionNames: str[]
  mut mainContent: str
}

obj ParserState {
  mut prevCh: char
  mut isComment: bool
  mut isDefinition: bool
  mut isFunction: bool
  mut isMain: bool
  mut blocks: int
}

obj Parser {
  mut _fileContent: str
  mut _result: ParserResult
  mut _state: ParserState

  fn parse (mut self: ref Self, filePath: str) ParserResult {
    self._fileContent = fs_readFileSync(filePath).str()
    self._result = ParserResult{}
    self._state = ParserState{}

    loop i := 0; i < self._fileContent.len; i++ {
      if self._state.isComment || self._isComment(i) {
        i = self._comment(i)
      } elif self._state.isDefinition || self._isDefinition(i) {
        i = self._definition(i)
      } elif self._state.isFunction || self._isFunction(i) {
        i = self._function(i)
      } elif self._state.isMain || self._isMain(i) {
        i = self._main(i)
      } else {
        self._result.content += self._fileContent[i].str()
      }

      self._state.prevCh = self._fileContent[i]
    }

    self._result.content = self._result.content.trim()

    if !self._result.content.empty {
      self._result.content += os_EOL
    }

    return self._result
  }

  fn _isComment (self: ref Self, i: int) bool {
    hasEscapeInFront := i != 0 && self._state.prevCh == '\\'
    nextIsComment := self._fileContent.slice(i, i + 3) == "/" + "*!"

    return !hasEscapeInFront && nextIsComment
  }

  fn _isDefinition (self: ref Self, i: int) bool {
    hasSpaceInFront := i == 0 || self._state.prevCh.isWhitespace
    nextIsEnum := self._fileContent.slice(i, i + 5) == "enum "
    nextIsObj := self._fileContent.slice(i, i + 4) == "obj "

    return hasSpaceInFront && (nextIsEnum || nextIsObj)
  }

  fn _isFunction (self: ref Self, i: int) bool {
    hasSpaceInFront := i == 0 || self._state.prevCh.isWhitespace
    nextIsFn := self._fileContent.slice(i, i + 3) == "fn "

    return hasSpaceInFront && nextIsFn
  }

  fn _isMain (self: ref Self, i: int) bool {
    hasSpaceInFront := i == 0 || self._state.prevCh.isWhitespace
    nextIsMain := self._fileContent.slice(i, i + 5) == "main "

    return hasSpaceInFront && nextIsMain
  }

  fn _comment (mut self: ref Self, mut i: int) int {
    ch := self._fileContent[i]
    nextIsComment := self._fileContent.slice(i, i + 3) == "/" + "*!"

    if !self._state.isComment && nextIsComment {
      self._result.comments += self._fileContent.slice(i, i + 3)
      self._state.isComment = true
      i += 2
    } elif self._fileContent.slice(i, i + 2) == "*/" {
      self._result.comments += self._fileContent.slice(i, i + 2) + os_EOL
      self._state.isComment = false
      i += 1
    } else {
      self._result.comments += ch.str()
    }

    return i
  }

  fn _definition (mut self: ref Self, mut i: int) int {
    ch := self._fileContent[i]
    nextIsEnum := self._fileContent.slice(i, i + 5) == "enum "
    nextIsObj := self._fileContent.slice(i, i + 4) == "obj "

    if !self._state.isDefinition && nextIsEnum {
      self._result.definitions += self._fileContent.slice(i, i + 5)
      self._state.isDefinition = true
      i += 4
    } elif !self._state.isDefinition && nextIsObj {
      self._result.definitions += self._fileContent.slice(i, i + 4)
      self._state.isDefinition = true
      i += 3
    } elif ch == '{' { // { // todo v0.15 - remove
      self._result.definitions += ch.str()
      self._state.blocks++
    } elif ch == '}' && self._state.blocks == 1 {
      self._result.definitions += ch.str() + os_EOL
      self._state.blocks--
      self._state.isDefinition = false
    } elif ch == '}' {
      self._result.definitions += ch.str()
      self._state.blocks--
    } else {
      self._result.definitions += ch.str()
    }

    return i
  }

  fn _function (mut self: ref Self, mut i: int) int {
    ch := self._fileContent[i]
    nextIsFn := self._fileContent.slice(i, i + 3) == "fn "

    if !self._state.isFunction && nextIsFn {
      self._result.functions += self._fileContent.slice(i, i + 3)
      self._state.isFunction = true
      i += 2

      loop j := i + 1; j < self._fileContent.len; j++ {
        ch := self._fileContent[j]

        if !ch.isLetterOrDigit && ch != '_' {
          name := self._fileContent.slice(i + 1, j)
          self._result.functionNames.push(name)
          break
        }
      }
    } elif ch == '{' { // { // todo v0.15 - remove
      self._result.functions += ch.str()
      self._state.blocks++
    } elif ch == '}' && self._state.blocks == 1 {
      self._result.functions += ch.str() + os_EOL
      self._state.blocks--
      self._state.isFunction = false
    } elif ch == '}' {
      self._result.functions += ch.str()
      self._state.blocks--
    } else {
      self._result.functions += ch.str()
    }

    return i
  }

  fn _main (mut self: ref Self, mut i: int) int {
    ch := self._fileContent[i]
    nextIsMain := self._fileContent.slice(i, i + 5) == "main "

    if !self._state.isMain && nextIsMain {
      self._result.mainContent += self._fileContent.slice(i, i + 5)
      self._state.isMain = true
      i += 4
    } elif ch == '{' { // { // todo v0.15 - remove
      self._result.mainContent += ch.str()
      self._state.blocks++
    } elif ch == '}' && self._state.blocks == 0 {
      self._result.mainContent += ch.str() + os_EOL
      self._state.isMain = false
    } elif ch == '}' {
      self._result.mainContent += ch.str()
      self._state.blocks--
    } else {
      self._result.mainContent += ch.str()
    }

    return i
  }
}
