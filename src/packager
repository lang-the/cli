/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

obj Package {
  name: str
  version: str
  cwd: str
  packagesTempPath: str
  mut _globalPath: str
  mut _initialized: bool
  mut _metaFile: str
  mut _packagesProjectPath: str
  mut _projectPath: str

  fn init (mut self: ref Self) ref Self {
    if self._initialized {
      RaiseError("tried package init on initialized")
    } elif !self.validName() {
      RaiseError("invalid package name")
    } elif !self.validVersion() {
      RaiseError("invalid package version")
    }

    Config_initHome(packageAuthor: self.getAuthor())
    locationName := self.getAuthor() + path_SEP + self.getProject()
    globalPackagePath := Config_getPackagesPath() + path_SEP + locationName

    self._packagesProjectPath = self.cwd + path_SEP + ".packages"
    self._globalPath = globalPackagePath + path_SEP + self.version
    self._metaFile = self.packagesTempPath + path_SEP + "packages" + path_SEP + locationName + ".yml"
    self._projectPath = self._packagesProjectPath + path_SEP + locationName

    if !fs_isFileSync(self._metaFile) {
      RaiseError("metadata of package `" + self.name + "` does not exists")
    }

    if !fs_existsSync(globalPackagePath) {
      fs_mkdirSync(globalPackagePath)
    }

    self._initialized = true
    return self
  }

  fn deinit (mut self: ref Self) {
    self._checkInitialized("deinit")
    self._initialized = false
  }

  fn download (self: ref Self) ref Self {
    self._checkInitialized("download")

    metaContent := fs_readFileSync(self._metaFile).str()
    meta := PackageMetadata_parse(metaContent)

    if !meta.existsVersion(self.version) {
      RaiseError(
        "package `" + self.name + "` " +
        "version `" + self.version + "` does not exists"
      )
    }

    tempPath := path_tempDirectory()

    process_runSync("git clone " + meta.repository + " '" + tempPath + "'")
    process_runSync("cd '" + tempPath + "' && git reset --hard " + meta.getVersionHash(self.version))
    removeDirectorySync(tempPath + path_SEP + ".git")
    fs_renameSync(tempPath + meta.repositoryPath, self._globalPath)

    if !meta.repositoryPath.empty {
      removeDirectorySync(tempPath)
    }

    mut packager := Packager{cwd: self._globalPath, tempPath: self.packagesTempPath}
    packager.init()
    packager.installAll()
    packager.deinit()

    return self
  }

  fn install (self: ref Self) ref Self {
    self._checkInitialized("install")

    if fs_existsSync(self._projectPath) {
      return self
    } elif !fs_existsSync(self._globalPath) {
      self.download()
    }

    if !fs_existsSync(self._packagesProjectPath) {
      fs_mkdirSync(self._packagesProjectPath)
    }

    author := self.getAuthor()

    if !fs_existsSync(self._packagesProjectPath + path_SEP + author) {
      fs_mkdirSync(self._packagesProjectPath + path_SEP + author)
    }

    fs_linkSync(self._globalPath, self._projectPath)
    return self
  }

  fn getAuthor (self: ref Self) str {
    nameParts := self.name.split("/")
    return nameParts[0]
  }

  fn getProject (self: ref Self) str {
    nameParts := self.name.split("/")
    return nameParts[1]
  }

  fn update (self: ref Self) ref Self {
    self._checkInitialized("update")
    // todo
    return self
  }

  fn validAuthor (self: ref Self) bool {
    val := self.getAuthor()

    loop i := 0; i < val.len; i++ {
      if !val[i].isLetterOrDigit {
        return false
      }
    }

    return val.lower == val
  }

  fn validName (self: ref Self) bool {
    parts := self.name.split("/")
    hasProject := parts.len == 2 && !parts[1].empty

    return hasProject ? self.validAuthor() && self.validProject() : false
  }

  fn validProject (self: ref Self) bool {
    val := self.getProject()

    loop i := 0; i < val.len; i++ {
      ch := val[i]

      if !ch.isLetterOrDigit && ch != '_' && ch != '-' && ch != '.' {
        return false
      }
    }

    return val.lower == val
  }

  fn validVersion (self: ref Self) bool {
    if self.version == "latest" {
      return true
    }

    mut part := 0

    loop i := 0; i < self.version.len; i++ {
      ch := self.version[i]

      if ch == '.' {
        if ++part == 3 {
          return false
        }
      } elif !ch.isDigit {
        return false
      }
    }

    return true
  }

  fn _checkInitialized (self: ref Self, callee: str) ref Self {
    if !self._initialized {
      RaiseError("tried package " + callee + " on non-initialized")
    }

    return self
  }
}

fn Package_fromArgument (val: str, packagesTempPath: str, cwd := process_cwd()) Package {
  parts := val.split("@")
  hasVersion := parts.len == 2 && !parts[1].empty

  mut result := Package{
    name: hasVersion ? parts[0] : val,
    version: hasVersion ? parts[1] : "latest",
    cwd: cwd,
    packagesTempPath: packagesTempPath
  }

  result.init()
  return result
}

obj Packager {
  cwd: str
  mut tempPath: str
  mut _initialized: bool
  mut _packages: Package[]
  mut _packageYAML: PackageYAML
  mut _packageYAMLPath: str
  mut _tempPathCreated: bool

  fn init (mut self: ref Self) ref Self {
    if self._initialized {
      RaiseError("tried packager init on initialized")
    }

    if self.tempPath.empty {
      self.tempPath = path_tempDirectory()
      self._tempPathCreated = true
      process_runSync("git clone --depth=1 https://github.com/thelang-io/packages.git '" + self.tempPath + "'")
    }

    self._packageYAMLPath = self.cwd + path_SEP + "package.yml"

    if fs_existsSync(self._packageYAMLPath) {
      packageYAMLContent := fs_readFileSync(self._packageYAMLPath).str()
      self._packageYAML = PackageYAML_parse(packageYAMLContent)
      packageYAMLPackagesNames := self._packageYAML.packages.keys
      packageYAMLPackagesVersions := self._packageYAML.packages.values

      loop i := 0; i < packageYAMLPackagesNames.len; i++ {
        self._packages.push(Package{
          name: packageYAMLPackagesNames[i],
          version: packageYAMLPackagesVersions[i],
          cwd: self.cwd,
          packagesTempPath: self.tempPath
        })
      }
    }

    self._initialized = true
    return self
  }

  fn deinit (mut self: ref Self) {
    self._checkInitialized("deinit")
    if self._tempPathCreated {
      removeDirectorySync(self.tempPath)
    }
    self._initialized = false
  }

  fn install (self: ref Self, argument: str) ref Self {
    self._checkInitialized("install")

    package := Package_fromArgument(argument, self.tempPath, cwd: self.cwd)
    package.install()

    if !self._packageYAML.packages.has(package.name) {
      self._packageYAML.packages.set(package.name, package.version)
    }

    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())
    return self.lock()
  }

  fn installAll (self: ref Self) ref Self {
    self._checkInitialized("installAll")

    loop i := 0; i < self._packages.len; i++ {
      mut package := self._packages[i]
      package.init()
      package.install()
    }

    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())
    return self.lock()
  }

  fn lock (self: ref Self) ref Self {
    self._checkInitialized("lock")
    // todo generate lock file
    return self
  }

  fn update (self: ref Self, argument: str) ref Self {
    self._checkInitialized("update")

    package := Package_fromArgument(argument, self.tempPath, cwd: self.cwd)
    package.update()

    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())
    return self.lock()
  }

  fn updateAll (self: ref Self) ref Self {
    self._checkInitialized("updateAll")

    loop i := 0; i < self._packages.len; i++ {
      mut package := self._packages[i]
      package.init()
      package.update()
    }

    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())
    return self.lock()
  }

  fn _checkInitialized (self: ref Self, callee: str) ref Self {
    if !self._initialized {
      RaiseError("tried packager " + callee + " on non-initialized")
    }

    return self
  }
}

fn Packager_init (cwd := process_cwd()) Packager {
  mut result := Packager{cwd: cwd}
  result.init()

  return result
}
