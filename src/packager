/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import Package, Package_fromArgument from "./package"
import PackageYAML, PackageYAML_parse from "./package-yaml"
import removeDirectorySync from "./utils"

export obj Packager {
  cwd: str
  mut tempPath: str
  mut _initialized: bool
  mut _packages: Package[]
  mut _packageYAML: PackageYAML
  mut _packageYAMLPath: str
  mut _tempPathCreated: bool

  fn init (mut self: ref Self) ref Self {
    if self._initialized {
      throw error_NewError("tried packager init on initialized")
    }

    if self.tempPath.empty {
      self.tempPath = path_tempDirectory()
      self._tempPathCreated = true
      process_runSync("git clone --depth=1 https://github.com/thelang-io/packages.git '" + self.tempPath + "' > /dev/null")
    }

    self._packageYAMLPath = self.cwd + path_SEP + "package.yml"

    if fs_existsSync(self._packageYAMLPath) {
      packageYAMLContent := fs_readFileSync(self._packageYAMLPath).str()
      self._packageYAML = PackageYAML_parse(packageYAMLContent)
      packageYAMLPackagesNames := self._packageYAML.packages.keys
      packageYAMLPackagesVersions := self._packageYAML.packages.values

      loop i := 0; i < packageYAMLPackagesNames.len; i++ {
        self._packages.push(Package{
          name: packageYAMLPackagesNames[i],
          version: packageYAMLPackagesVersions[i],
          cwd: self.cwd,
          packagesTempPath: self.tempPath
        })
      }
    }

    self._initialized = true
    return self
  }

  fn deinit (mut self: ref Self) {
    self._checkInitialized("deinit")
    if self._tempPathCreated {
      removeDirectorySync(self.tempPath)
    }
    self._initialized = false
  }

  fn install (self: ref Self, argument: str) ref Self {
    self._checkInitialized("install")

    package := Package_fromArgument(argument, self.tempPath, cwd: self.cwd)
    package.install()

    self._packageYAML.packages.set(package.name, package.version)
    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())

    return self.lock()
  }

  fn installAll (self: ref Self) ref Self {
    self._checkInitialized("installAll")

    loop i := 0; i < self._packages.len; i++ {
      mut package := self._packages[i]
      package.init()
      package.install()
    }

    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())
    return self.lock()
  }

  fn lock (self: ref Self) ref Self {
    self._checkInitialized("lock")
    // todo v0.14 - generate package.lock file with hashes of packages
    return self
  }

  fn uninstall (self: ref Self, argument: str) ref Self {
    self._checkInitialized("uninstall")

    package := Package_fromArgument(argument, self.tempPath, cwd: self.cwd)
    package.uninstall()

    if self._packageYAML.packages.has(package.name) {
      self._packageYAML.packages.remove(package.name)
    }

    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())
    return self.lock()
  }

  fn update (self: ref Self, argument: str) ref Self {
    self._checkInitialized("update")

    package := Package_fromArgument(argument, self.tempPath, cwd: self.cwd)
    package.update()

    self._packageYAML.packages.set(package.name, package.version)
    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())

    return self.lock()
  }

  fn updateAll (self: ref Self) ref Self {
    self._checkInitialized("updateAll")

    loop i := 0; i < self._packages.len; i++ {
      mut package := self._packages[i]
      package.init()
      package.update()
      self._packageYAML.packages.set(package.name, package.version)
    }

    fs_writeFileSync(self._packageYAMLPath, self._packageYAML.stringify().toBuffer())
    return self.lock()
  }

  fn _checkInitialized (self: ref Self, callee: str) ref Self {
    if !self._initialized {
      throw error_NewError("tried packager " + callee + " on non-initialized")
    }

    return self
  }
}

export fn Packager_init (cwd := process_cwd()) Packager {
  mut result := Packager{cwd: cwd}
  result.init()
  return result
}

export fn Packager_installAll (cwd: str, tempPath: str) {
  mut packager := Packager{cwd: cwd, tempPath: tempPath}
  packager.init()
  packager.installAll()
  packager.deinit()
}
