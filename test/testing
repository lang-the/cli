/*!
 * Copyright (c) 2018 Aaron Delasy
 * Licensed under the MIT License
 */

mut testFailed := false

fn matchIntToInt (val1: int, val2: int) {
  if val1 != val2 {
    testFailed = true
    // todo print actual error
  }
}

fn matcherMismatch (val1: any, val2: any) {
  testFailed = true
  // todo print error
}

obj expect {
  data: any

  fn toEqual (mut self: ref Self, val: any) ref Self {
    if self.data is int && val is int { matchIntToInt(self.data, val) }
    elif self.data is int { matcherMismatch(self.data, val) }

    return self
  }
}

obj Test {
  name: str
  body: () -> void
}

obj Tests {
  _tests: Test[]

  fn register (mut self: ref Self, name: str, body: () -> void) ref Self {
    self._tests.push(Test{name: name, body: body})
    return self
  }

  fn run (mut self: ref Self. args: str[]) ref Self {
    // todo print tests start

    loop i := 0; i < self._tests.len; i++ {
      test := self._tests[i]

      // todo print test start
      test.body()

      if testFailed {
        // todo print test failed
      } else {
        // todo print test succeeded
      }

      testFailed = false
    }

    // todo print tests end
  }
}
